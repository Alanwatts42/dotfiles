#!/usr/bin/sh

# Title:      kick_shell
# Author:     Evan Sherwood
# Email:  evan.sherwood@keemail.me
# Location:  '$HOME/.kick_shell'

# A place I keep anything useful I've written for shell scripting that 
# doesn't strictly belong anywhere else, mostly functions.


#############################################################################
#                           System Utilities
#############################################################################


# kill zombie processes - finds processes that should have been killed but are still alive
killzombies () {
    DFZ=$(ps axo stat,ppid,pid,comm | grep -w defunct);
    if sudo kill -9 "$DFZ";then
        echo "Zombie process(es) have been killed";else
            echo "I guess it didn't work, maybe no zombies?"
    fi
}


# doainloopb [for each part of iterable] "$1" [run command] "$2"
# example: doainloopb ls chmod +x  =  list contents of current directory and run chmod +x on each 
# item in that list in other words, loop through working directory and make each file executable.
forloop () {
    echo enter file extension of files in "$(pwd)" to loop through
    read -r ext 
    echo now enter the operation to perform on each loop
    read -r op
    for i in *."$ext";do
        "$op" "$i"
    done
    echo it is done! Now look upon what your foolishness has wrought!
    ls
}


## run something with no terminal output (quietly)
hush () {
    "$1" >/dev/null #"$2" >&"$1" (std.err to /dev/null)
}


## copy the contents of a text file to the clipboard
clipfile () {
    xclip -i -selection c "$1"
}

# Shortcut for fix procedure for common issue with '.zsh_history' if it gets corrupted
badzshhistoryfix () {
    mv .zsh_history .zsh_history_bad;
    strings .zsh_history_bad > .zsh_history;
    fc -R .zsh_history;
    echo ".zsh_history should be fixed now"
}

#############################################################################
#                           Hardware Utilities
#############################################################################

## it's called wificonnect, you get one guess what it does
wificonnect () { 
    sudo nmcli dev wifi connect "$1" password "$2"
}

# CPU scaling - set a limit on CPU clock speed (usually only to save power).
setgov ()
{
    echo "$1" | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor 
}


#############################################################################
#                         Software Updates (apt-get)
#############################################################################

# Clear out any unnecessary or chached packages, then update and upgrade. A good general update function.
aptsweep () {
    sudo apt-get check;
    sudo apt-get clean;
    sudo apt-get autoclean;
    sudo apt-get autoremove -y;
    sudo apt-get update;
    sudo apt-get dist-upgrade -y;
}

# List all packages known to synaptic 'apt' and show those matching search pattern "@"
applist () {
    apt list | grep "$@"
}


# Update, upgrade, then install new package as well as any related packages suggested by synaptic
upinstall () {
    sudo apt-get update -y;
    sudo apt-get upgrade -y;
    sudo apt-get install "$@" --install-suggests -y
}

# Update, upgrade, and then install a package via apt-get
suinstall () {
    echo "alright, installing...";
    sudo apt-get update && sudo apt-get dist-upgrade;
    sudo apt-get install "$1"
}

# Search all packages known to synaptic for pattern "$1", but exclude any that have already been installed. (May not differentiate i386 & x86_64)
aptsearchnew () {
    apt search "$1" | grep -v "[installed]"
}

# i386 Install - an easy way to install the i386 version of anything on apt
# Note: Takes a single string as input, can't use "$@" due to the ":i386" part
install86 () {
    sudo apt-get update -y;
    sudo apt-get install "$1" --install-suggests -y;
    sudo apt-get install "$1":i386 --install-suggests -y
}


#############################################################################
#                         Downloads (wget & curl)
#############################################################################

# Download a link with wget and then unzip it with 'unzip'
wgetzip () {
    wget "$1";
    if [ "$(unzip "$1")" ];then
        echo unzipping...;else
        if [ "$(7z x "$i")" ];then
            echo unarchiving with 7z...;else
                echo file type not zip or 7z, use other method
        fi
    fi
}



# Sends any output of command "$1" to /dev/null, effectively running it silently.
hush () {
    "$1" >/dev/null 2>&1
}

# Download file from 'the-eye.eu' site directory structure without having to provide the full url. Side effect is that file will be nested in multiple dirs.
eyewget () {
    wget -m -np -c -U "eye01" -R "index.html*" "$@"
}

# Download game from 'the-eye.eu', same side effect applies.
wgame () {
    wget -m -np -nd -c -U "eye01" -R "index.html*" 'http://the-eye.eu/public/Games/Linux/"$@"'
}

# Download all games in a directory of 'the-eye.eu', same side effect applies.
eyeallgames () {
    wget -m -np -cr -U "eye01" -R "index.html*" "http://the-eye.eu/public/Games/Linux/"
}


# Download psx rom from url to the correct retropie directory and if download is successful, unarchive it with ripsaw.
wgetpsx () {
    cd ~/RetroPie/roms/psx || exit;
    if wget -c -t 99 --retry-connrefused "$@" --no-check-certificate;then
        ripsaw
    else
        echo "download incomplete, ripsaw did not run"
    fi
}

# Same as wgetpsx but for dreamcast roms
wgetdc () {
    cd ~/RetroPie/roms/dreamcast || exit;
    if wget -c -t 999 --retry-connrefused "$@" --no-check-certificate;then
        ripsaw
    else 
        echo "download incomplete, ripsaw did not run"    
    fi
}

## time-delayed resume operation (after ctrl-z)
resumeafter () {
    echo "resuming process after ${1} minutes"
    sleep "$1"m && fg
}

## wget --no-check-certificate
wgetnc () {
    if wget -c -t 999 --retry-connrefused "$@" --no-check-certificate;then
        ripsaw
    else
        echo "download incomplete, ripsaw did not run"
    fi
}


#############################################################################
#                          Version Control (git)                      
#############################################################################


## run install using synaptic and treat suggestions as dependencies
shinstall () { 
    sudo apt-get update && sudo apt-get dist-upgrade --fix-missing -y;
    sudo apt-get -fm install "$@" --install-suggests -y
}

## update a git repository with commit message (gitup [commit message])
gitup () {
   git add --all;    
   git commit -m "$1"; 
   git push;
}

# quickly add all changes and push to remote
# with generic commit message 'minor edits'
gitsync () {
   git add --all;    
   git commit -m "minor edits"; 
   git push;
}


#############################################################################
#                           Miscellaneous Scripting                    
#############################################################################

# [put new misc functions here]


##############################################################################
#                           Inactive or Unfinispuhed
##############################################################################

# # pipe terminal output to vim
# vimget () {
#     # shellcheck disable=SC2039
#     # vim <("$@")
# }
# # pipe terminal output to less text viewer
# lessget () {
#     # shellcheck disable=SC2039
#     less -f <('$@')
# }

# Loops over every item in the current dir and executes user input operation(s) "$@"
# xloopallx () {
#     printf "Run what?\n\n"
#     read @
#     printf "\n\nExecute '$@' on ALL items in directory: '$(pwd)'?\n\n"
#     read cmdgo
#     if [cmdgo != "n"]
#     for i in *;do
#         "$@" "$i"
#     done
# }

